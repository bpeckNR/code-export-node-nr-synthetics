// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Code Export Java JUnit Selenium should export a suite 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  // Test Case: valid credentials  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( function Open() {
      logger.log(1, \\"Open URL http://the-internet.herokuapp.com/login\\", \\"it\\");
      return $browser.get(\\"http://the-internet.herokuapp.com/login\\").then(val => {
        return val;
      });
    })
    .then( function SetWindow() {
      logger.log(2, \\"Set Window Size Width=1440 Height=1177\\", \\"it\\");
      return $browser.manage().window().setSize(1440, 1177).then(val => {
        return val;
      });
    })
    .then( function SendKeys() {
      logger.log(3, \\"Type \\\\\\"tomsmith\\\\\\" using locator By.id(\\\\\\"username\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.id(\\"username\\"), DefaultTimeout).then(el => {
        el.sendKeys(\\"tomsmith\\");
        return Promise.resolve(true);
      });
    })
    .then( function SendKeys() {
      logger.log(4, \\"Type \\\\\\"SuperSecretPassword!\\\\\\" using locator By.id(\\\\\\"password\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.id(\\"password\\"), DefaultTimeout).then(el => {
        el.sendKeys(\\"SuperSecretPassword!\\");
        return Promise.resolve(true);
      });
    })
    .then( function Click() {
      logger.log(5, \\"Click By.css(\\\\\\"#login button\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.css(\\"#login button\\"), DefaultTimeout).then(el => {
        el.click();
        return Promise.resolve(true);
      });
    })
    .then( function VerifyText() {
      logger.log(6, \\"Verify Text You logged into a secure area!\\\\n× using By.css(\\\\\\".flash.success\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.css(\\".flash.success\\"), DefaultTimeout).then(el => {
        return el.getText().then(value => {
          assert.strictEqual(\\"You logged into a secure area!\\\\\\\\n×\\", value);
          return Promise.resolve(true);
        });
      });
    })
  	.then(function() {
  		logger.endTestCase(\\"valid credentials\\");
  	}, function(err) {
  		logger.error (err, \\"valid credentials\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: invalid credentials  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( function Open() {
      logger.log(7, \\"Open URL http://the-internet.herokuapp.com/login\\", \\"it\\");
      return $browser.get(\\"http://the-internet.herokuapp.com/login\\").then(val => {
        return val;
      });
    })
    .then( function SetWindow() {
      logger.log(8, \\"Set Window Size Width=1440 Height=1177\\", \\"it\\");
      return $browser.manage().window().setSize(1440, 1177).then(val => {
        return val;
      });
    })
    .then( function SendKeys() {
      logger.log(9, \\"Type \\\\\\"blah\\\\\\" using locator By.id(\\\\\\"username\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.id(\\"username\\"), DefaultTimeout).then(el => {
        el.sendKeys(\\"blah\\");
        return Promise.resolve(true);
      });
    })
    .then( function SendKeys() {
      logger.log(10, \\"Type \\\\\\"blah\\\\\\" using locator By.id(\\\\\\"password\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.id(\\"password\\"), DefaultTimeout).then(el => {
        el.sendKeys(\\"blah\\");
        return Promise.resolve(true);
      });
    })
    .then( function Click() {
      logger.log(11, \\"Click By.css(\\\\\\"#login button\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.css(\\"#login button\\"), DefaultTimeout).then(el => {
        el.click();
        return Promise.resolve(true);
      });
    })
    .then( function VerifyText() {
      logger.log(12, \\"Verify Text Your username is invalid!\\\\n× using By.id(\\\\\\"flash\\\\\\")\\", \\"it\\");
      return $browser.waitForAndFindElement(By.id(\\"flash\\"), DefaultTimeout).then(el => {
        return el.getText().then(value => {
          assert.strictEqual(\\"Your username is invalid!\\\\\\\\n×\\", value);
          return Promise.resolve(true);
        });
      });
    })
  	.then(function() {
  		logger.endTestCase(\\"invalid credentials\\");
  	}, function(err) {
  		logger.error (err, \\"invalid credentials\\");
  		throw(err);
  	});
  
  })
  
 
"
`;

exports[`Code Export Java JUnit Selenium should export a suite that uses control flow commands 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  // Test Case: control flow if  
  .then(function (){
  	return Promise.resolve(true)
  
    .then(_=>{
      return $browser.executeScript(\\"return 'a'\\")
      .then(function(result){
        vars.set(\\"myVar\\", result)
        return Promise.resolve(true)
      })
    })
      if ($browser.executeScript(\\"return (arguments[0] === 'a')\\", vars.get(\\"myVar\\"))) {
        .then(_=>{
          return $browser.executeScript(\\"return 'a'\\")
          .then(function(result){
            vars.set(\\"output\\", result)
            return Promise.resolve(true)
          })
        })
        } else if ($browser.executeScript(\\"return (arguments[0] === 'b')\\", vars.get(\\"myVar\\"))) {
          .then(_=>{
            return $browser.executeScript(\\"return 'b'\\")
            .then(function(result){
              vars.set(\\"output\\", result)
              return Promise.resolve(true)
            })
          })
          } else {
            .then(_=>{
              return $browser.executeScript(\\"return 'c'\\")
              .then(function(result){
                vars.set(\\"output\\", result)
                return Promise.resolve(true)
              })
            })
            }
          })
          .then( function Assert() {
      logger.log(1, \\"Assert on output is a\\", \\"it\\");
      assert.equal(vars.get(\\"output\\"), \\"a\\");
      return Promise.resolve(true);
    })
  	.then(function() {
  		logger.endTestCase(\\"send KEY_ENTER\\");
  	}, function(err) {
  		logger.error (err, \\"send KEY_ENTER\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: control flow else if  
  .then(function (){
  	return Promise.resolve(true)
  
    .then(_=>{
      return $browser.executeScript(\\"return 'b'\\")
      .then(function(result){
        vars.set(\\"myVar\\", result)
        return Promise.resolve(true)
      })
    })
      if ($browser.executeScript(\\"return (arguments[0] === 'a')\\", vars.get(\\"myVar\\"))) {
        .then(_=>{
          return $browser.executeScript(\\"return 'a'\\")
          .then(function(result){
            vars.set(\\"output\\", result)
            return Promise.resolve(true)
          })
        })
        } else if ($browser.executeScript(\\"return (arguments[0] === 'b')\\", vars.get(\\"myVar\\"))) {
          .then(_=>{
            return $browser.executeScript(\\"return 'b'\\")
            .then(function(result){
              vars.set(\\"output\\", result)
              return Promise.resolve(true)
            })
          })
          } else {
            .then(_=>{
              return $browser.executeScript(\\"return 'c'\\")
              .then(function(result){
                vars.set(\\"output\\", result)
                return Promise.resolve(true)
              })
            })
            }
          })
          .then( function Assert() {
      logger.log(2, \\"Assert on output is b\\", \\"it\\");
      assert.equal(vars.get(\\"output\\"), \\"b\\");
      return Promise.resolve(true);
    })
  	.then(function() {
  		logger.endTestCase(\\"control flow if\\");
  	}, function(err) {
  		logger.error (err, \\"control flow if\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: control flow else  
  .then(function (){
  	return Promise.resolve(true)
  
    .then(_=>{
      return $browser.executeScript(\\"return 'c'\\")
      .then(function(result){
        vars.set(\\"myVar\\", result)
        return Promise.resolve(true)
      })
    })
      if ($browser.executeScript(\\"return (arguments[0] === 'a')\\", vars.get(\\"myVar\\"))) {
        .then(_=>{
          return $browser.executeScript(\\"return 'a'\\")
          .then(function(result){
            vars.set(\\"output\\", result)
            return Promise.resolve(true)
          })
        })
        } else if ($browser.executeScript(\\"return (arguments[0] === 'b')\\", vars.get(\\"myVar\\"))) {
          .then(_=>{
            return $browser.executeScript(\\"return 'b'\\")
            .then(function(result){
              vars.set(\\"output\\", result)
              return Promise.resolve(true)
            })
          })
          } else {
            .then(_=>{
              return $browser.executeScript(\\"return 'c'\\")
              .then(function(result){
                vars.set(\\"output\\", result)
                return Promise.resolve(true)
              })
            })
            }
          })
          .then( function Assert() {
      logger.log(3, \\"Assert on output is c\\", \\"it\\");
      assert.equal(vars.get(\\"output\\"), \\"c\\");
      return Promise.resolve(true);
    })
  	.then(function() {
  		logger.endTestCase(\\"control flow else if\\");
  	}, function(err) {
  		logger.error (err, \\"control flow else if\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: control flow do  
  .then(function (){
  	return Promise.resolve(true)
  
    .then(_=>{
      return $browser.executeScript(\\"return 1\\")
      .then(function(result){
        vars.set(\\"check\\", result)
        return Promise.resolve(true)
      })
    })
    .then(function ControlFlowDo(){
      var keepGoing=false
      do {
      .then(_=>{
        return $browser.executeScript(\\"return arguments[0] + 1\\", vars.get(\\"check\\"))
        .then(function(result){
          vars.set(\\"check\\", result)
          return Promise.resolve(true)
        })
      })
        .then(function (){
          return $browser.executeScript(\\"return (arguments[0] < 3)\\", vars.get(\\"check\\"))
        })
        .then(function (ret){
          keepGoing = (Boolean)ret
        })
      } while (keepGoing) 
    })
    .then( function Assert() {
      logger.log(4, \\"Assert on check is 3\\", \\"it\\");
      assert.equal(vars.get(\\"check\\"), \\"3\\");
      return Promise.resolve(true);
    })
  	.then(function() {
  		logger.endTestCase(\\"control flow else\\");
  	}, function(err) {
  		logger.error (err, \\"control flow else\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: control flow times  
  .then(function (){
  	return Promise.resolve(true)
  
    .then(_=>{
      return $browser.executeScript(\\"return 1\\")
      .then(function(result){
        vars.set(\\"check\\", result)
        return Promise.resolve(true)
      })
    })
    .then(function ControlFlowTimes(){
      var times = 2;
      for(int i = 0; i < times; i++) {
        .then(_=>{
          return $browser.executeScript(\\"return arguments[0] + 1\\", vars.get(\\"check\\"))
          .then(function(result){
            vars.set(\\"check\\", result)
            return Promise.resolve(true)
          })
        })
        }
      })
      .then( function Assert() {
      logger.log(5, \\"Assert on check is 3\\", \\"it\\");
      assert.equal(vars.get(\\"check\\"), \\"3\\");
      return Promise.resolve(true);
    })
  	.then(function() {
  		logger.endTestCase(\\"control flow do\\");
  	}, function(err) {
  		logger.error (err, \\"control flow do\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: control flow while  
  .then(function (){
  	return Promise.resolve(true)
  
    .then(_=>{
      return $browser.executeScript(\\"return 1\\")
      .then(function(result){
        vars.set(\\"check\\", result)
        return Promise.resolve(true)
      })
    })
    while ($browser.executeScript(\\"return (arguments[0] < 3)\\", vars.get(\\"check\\"))) {
      .then(_=>{
        return $browser.executeScript(\\"return arguments[0] + 1\\", vars.get(\\"check\\"))
        .then(function(result){
          vars.set(\\"check\\", result)
          return Promise.resolve(true)
        })
      })
      }
    })
    .then( function Assert() {
      logger.log(6, \\"Assert on check is 3\\", \\"it\\");
      assert.equal(vars.get(\\"check\\"), \\"3\\");
      return Promise.resolve(true);
    })
  	.then(function() {
  		logger.endTestCase(\\"control flow times\\");
  	}, function(err) {
  		logger.error (err, \\"control flow times\\");
  		throw(err);
  	});
  
  })
  
 
"
`;

exports[`Code Export Java JUnit Selenium should export a suite with a reused test method 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  function login(){
  	return Promise.resolve(true)
    [object Object]
    [object Object]
    [object Object]
    [object Object]
    [object Object]
  	.then(function() {
  		logger.endTestCase(\\"__TC_NAME__\\");
  	}, function(err) {
  		logger.error (err, \\"__TC_NAME__\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: invalid credentials  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( _=>{ vars.set(\\"username\\", blah);)
    .then( _=>{ vars.set(\\"password\\", blah);)
    // reusable RUN() scripts not supported
  	.then(function() {
  		logger.endTestCase(\\"login\\");
  	}, function(err) {
  		logger.error (err, \\"login\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: valid credentials  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( _=>{ vars.set(\\"username\\", tomsmith);)
    .then( _=>{ vars.set(\\"password\\", SuperSecretPassword!);)
    // reusable RUN() scripts not supported
  	.then(function() {
  		logger.endTestCase(\\"valid credentials\\");
  	}, function(err) {
  		logger.error (err, \\"valid credentials\\");
  		throw(err);
  	});
  
  })
  
 
"
`;

exports[`Code Export Java JUnit Selenium should export a suite with commands that open a new window inside of a reused test method 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  function selectwindow(){
  	return Promise.resolve(true)
    [object Object]
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then(wHandles=>{
           vars.set(\\"window_handles\\", wHandles);
           return Promise.resolve(true)
        }) 
    })
    .then( function Click() {
          logger.log(__STEP__, \\"Click By.linkText(\\\\\\"Click Here\\\\\\")\\", \\"__TC_NAME__\\");
          return $browser.waitForAndFindElement(By.linkText(\\"Click Here\\"), DefaultTimeout).then(el => {
            el.click();
            return Promise.resolve(true);
          });
        })
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then( wHandles=>{
           let prevHandles = new Set(vars.get(\\"window_handles\\"))
           let currHandles = wHandles
           let diff = new Set ([...currHandles].filter(x => !prevHandles.has(x)))  
           vars.set(\\"win9425\\", diff.values().next().value);
           return Promise.resolve(true)
        })
    })
    
    [object Object]
    [object Object]
  	.then(function() {
  		logger.endTestCase(\\"__TC_NAME__\\");
  	}, function(err) {
  		logger.error (err, \\"__TC_NAME__\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: reuse  
  .then(function (){
  	return Promise.resolve(true)
  
    // reusable RUN() scripts not supported
  	.then(function() {
  		logger.endTestCase(\\"reuse\\");
  	}, function(err) {
  		logger.error (err, \\"reuse\\");
  		throw(err);
  	});
  
  })
  
 
"
`;

exports[`Code Export Java JUnit Selenium should export a suite with just one new window util method when there are multiple commands that open a new window 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  function selectwindow(){
  	return Promise.resolve(true)
    [object Object]
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then(wHandles=>{
           vars.set(\\"window_handles\\", wHandles);
           return Promise.resolve(true)
        }) 
    })
    .then( function Click() {
          logger.log(__STEP__, \\"Click By.linkText(\\\\\\"Click Here\\\\\\")\\", \\"__TC_NAME__\\");
          return $browser.waitForAndFindElement(By.linkText(\\"Click Here\\"), DefaultTimeout).then(el => {
            el.click();
            return Promise.resolve(true);
          });
        })
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then( wHandles=>{
           let prevHandles = new Set(vars.get(\\"window_handles\\"))
           let currHandles = wHandles
           let diff = new Set ([...currHandles].filter(x => !prevHandles.has(x)))  
           vars.set(\\"win9425\\", diff.values().next().value);
           return Promise.resolve(true)
        })
    })
    
    [object Object]
    [object Object]
  	.then(function() {
  		logger.endTestCase(\\"__TC_NAME__\\");
  	}, function(err) {
  		logger.error (err, \\"__TC_NAME__\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: reuse  
  .then(function (){
  	return Promise.resolve(true)
  
    // reusable RUN() scripts not supported
  	.then(function() {
  		logger.endTestCase(\\"reuse\\");
  	}, function(err) {
  		logger.error (err, \\"reuse\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: select window  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( function Open() {
      logger.log(1, \\"Open URL http://the-internet.herokuapp.com/windows\\", \\"it\\");
      return $browser.get(\\"http://the-internet.herokuapp.com/windows\\").then(val => {
        return val;
      });
    })
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then(wHandles=>{
           vars.set(\\"window_handles\\", wHandles);
           return Promise.resolve(true)
        }) 
    })
    .then( function Click() {
          logger.log(2, \\"Click By.linkText(\\\\\\"Click Here\\\\\\")\\", \\"it\\");
          return $browser.waitForAndFindElement(By.linkText(\\"Click Here\\"), DefaultTimeout).then(el => {
            el.click();
            return Promise.resolve(true);
          });
        })
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then( wHandles=>{
           let prevHandles = new Set(vars.get(\\"window_handles\\"))
           let currHandles = wHandles
           let diff = new Set ([...currHandles].filter(x => !prevHandles.has(x)))  
           vars.set(\\"win9425\\", diff.values().next().value);
           return Promise.resolve(true)
        })
    })
    .then( function SwitchToWindow() {
      logger.log(3, \\"Switch to Window using Handle vars.get(\\\\\\"win9425\\\\\\")\\", \\"it\\");
      return Promise.resolve($browser.switchTo().window(vars.get(\\"win9425\\")));
    })
    .then( function VerifyTitle() {
      logger.log(4, \\"Verify Title New Window\\", \\"it\\");
      return $browser.getTitle().then(result => {
        assert.strictEqual(\\"New Window\\", result.trim());
        return Promise.resolve(true);
      });
    })
  	.then(function() {
  		logger.endTestCase(\\"select window\\");
  	}, function(err) {
  		logger.error (err, \\"select window\\");
  		throw(err);
  	});
  
  })
  
 
"
`;

exports[`Code Export Java JUnit Selenium should export a test 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  // Test Case: login  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( function Open() {
      logger.log(1, \\"Open URL http://the-internet.herokuapp.com/login\\", \\"login\\");
      return $browser.get(\\"http://the-internet.herokuapp.com/login\\").then(val => {
        return val;
      });
    })
    .then( function SetWindow() {
      logger.log(2, \\"Set Window Size Width=1440 Height=1177\\", \\"login\\");
      return $browser.manage().window().setSize(1440, 1177).then(val => {
        return val;
      });
    })
    .then( function SendKeys() {
      logger.log(3, \\"Type \\\\\\"tomsmith\\\\\\" using locator By.id(\\\\\\"username\\\\\\")\\", \\"login\\");
      return $browser.waitForAndFindElement(By.id(\\"username\\"), DefaultTimeout).then(el => {
        el.sendKeys(\\"tomsmith\\");
        return Promise.resolve(true);
      });
    })
    .then( function SendKeys() {
      logger.log(4, \\"Type \\\\\\"SuperSecretPassword!\\\\\\" using locator By.id(\\\\\\"password\\\\\\")\\", \\"login\\");
      return $browser.waitForAndFindElement(By.id(\\"password\\"), DefaultTimeout).then(el => {
        el.sendKeys(\\"SuperSecretPassword!\\");
        return Promise.resolve(true);
      });
    })
    .then( function Click() {
      logger.log(5, \\"Click By.css(\\\\\\"#login button\\\\\\")\\", \\"login\\");
      return $browser.waitForAndFindElement(By.css(\\"#login button\\"), DefaultTimeout).then(el => {
        el.click();
        return Promise.resolve(true);
      });
    })
    .then( function VerifyText() {
      logger.log(6, \\"Verify Text You logged into a secure area!\\\\n× using By.css(\\\\\\".flash.success\\\\\\")\\", \\"login\\");
      return $browser.waitForAndFindElement(By.css(\\".flash.success\\"), DefaultTimeout).then(el => {
        return el.getText().then(value => {
          assert.strictEqual(\\"You logged into a secure area!\\\\\\\\n×\\", value);
          return Promise.resolve(true);
        });
      });
    })
  	.then(function() {
  		logger.endTestCase(\\"login\\");
  	}, function(err) {
  		logger.error (err, \\"login\\");
  		throw(err);
  	});
  
  })
  
"
`;

exports[`Code Export Java JUnit Selenium should export a test with a reused test method 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  function login(){
  	return Promise.resolve(true)
    [object Object]
    [object Object]
    [object Object]
    [object Object]
    [object Object]
  	.then(function() {
  		logger.endTestCase(\\"valid credentials\\");
  	}, function(err) {
  		logger.error (err, \\"valid credentials\\");
  		throw(err);
  	});
  
  })
  
  // Test Case: valid credentials  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( _=>{ vars.set(\\"username\\", tomsmith);)
    .then( _=>{ vars.set(\\"password\\", SuperSecretPassword!);)
    // reusable RUN() scripts not supported
  	.then(function() {
  		logger.endTestCase(\\"valid credentials\\");
  	}, function(err) {
  		logger.error (err, \\"valid credentials\\");
  		throw(err);
  	});
  
  })
  
"
`;

exports[`Code Export Java JUnit Selenium should export a test with commands that open a new window 1`] = `
"// Generated by Selenium IDE
// New Relic Synthetics Formatter for Selenium IDE
// Feel free to explore, or check out the full documentation
// https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/scripting-monitors/writing-scripted-browsers
// for details
// generateSuiteDeclaration
  const assert = require(\\"assert\\");
  const urlRequest = require(\\"urllib\\").request;
  // Theshold for duration of entire script - fails test if script lasts longer than X (in ms)
  // Script-wide timeout for all wait and waitAndFind functions (in ms)
  var DefaultTimeout = 30000;
  // Change to any User Agent you want to use.
  // Leave as \\"default\\" or empty to use the Synthetics default.
  var UserAgent = \\"default\\";
  const By = $driver.By;
  const browser = $browser.manage();
  var vars = new Map();
  const logger = function ({
  timeout = 3000,
  stepLogging = false,
  insightsKey = ''
}) {
  const startTime = Date.now();
  var stepStartTime = 0,
      prevMsg = '',
      currStep = 0,
      prevStep = 0;

  function postInsights({
    step = 0,
    msg = '',
    duration = 0,
    eventType = 'SyntheticsCustom',
    custom = {}
  }) {
    if (typeof insightsKey == 'undefined' || insightsKey == '') return;
    var insightsOptions = {
      method: 'POST',
      headers: {
        'X-Insert-Key': insightsKey,
        'Content-Type': 'application/json'
      },
      data: {
        eventType,
        step,
        message: msg,
        duration,
        JOB_ID: $env.JOB_ID,
        MONITOR_ID: $env.MONITOR_ID,
        ACCOUNT_ID: $env.ACCOUNT_ID,
        LOCATION: $env.LOCATION,
        PROXY_HOST: $env.PROXY_HOST,
        PROXY_PORT: $env.PROXY_PORT
      },
      dataType: 'text'
    };
    const url = \`https://insights-collector.newrelic.com/v1/accounts/\${$env.ACCOUNT_ID}/events\`;
    insightsOptions.data = Object.assign({}, insightsOptions.data, custom); // insightsOptions.data = {...insightsOptions.data , ...custom }

    urlRequest(url, insightsOptions);
  }

  function getStep() {
    return currStep;
  }

  function logStep(msg) {
    log(currStep++, msg);
  }

  function log(thisStep, thisMsg, testCase = '') {
    if (thisStep > prevStep && prevStep != 0) {
      end({
        testCase
      });
    }

    stepStartTime = Date.now() - startTime;
    let msg = \`Step \${thisStep}: \${thisMsg} STARTED at \${stepStartTime}ms. testCase=\${testCase}\`;
    console.log(msg);
    prevMsg = thisMsg;
    prevStep = thisStep;
  }

  function end({
    testCase = ''
  }) {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete. testCase=\${testCase}\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    if (timeout > 0 && totalTimeElapsed > timeout) {
      throw new Error('Script timed out. ' + totalTimeElapsed + 'ms is longer than script timeout threshold of ' + timeout + 'ms.');
    }
  }

  function endTestCase(testCase = \\"\\") {
    var totalTimeElapsed = Date.now() - startTime;
    var prevStepTimeElapsed = totalTimeElapsed - stepStartTime;
    console.log(\`Step \${prevStep}: \${prevMsg} FINISHED. It took \${prevStepTimeElapsed}ms to complete.\`); // use Step log msgs as attributes in Insights

    if (stepLogging && insightsKey.length > 0) {
      // $util.insights.set(\`Step \${prevStep}: \${prevMsg}\`, prevStepTimeElapsed)
      postInsights({
        step: prevStep,
        msg: prevMsg,
        duration: prevStepTimeElapsed,
        custom: {
          testCase
        }
      });
    }

    $util.insights.set('testCase', testCase);
    $util.insights.set(\`testCaseStatus\`, 'Pass');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Pass'
        }
      });
    }
  }

  function error(err, testCase = \\"\\") {
    console.log(\`Error in Step \${prevStep}: \${prevMsg}\`);
    $util.insights.set(\`errorStep\`, \`\${prevStep}\`);
    $util.insights.set(\`errorMsg\`, err.message);
    $util.insights.set(\`errorLineNumber\`, err.lineNumber);
    $util.insights.set(\`testCase\`, testCase);
    $util.insights.set(\`testCaseStatus\`, 'fail');

    if (stepLogging && insightsKey.length > 0) {
      postInsights({
        eventType: 'SyntheticsTests',
        custom: {
          testCase,
          testCaseStatus: 'Fail'
        }
      });
    }
  }

  return {
    logStep,
    log,
    getStep,
    end,
    endTestCase,
    error,
    postInsights
  };
}({timeout:180000, stepLogging:false, })
  $browser.getCapabilities().then(function () { })
  // Test Case: select window  
  .then(function (){
  	return Promise.resolve(true)
  
    .then( function Open() {
      logger.log(1, \\"Open URL http://the-internet.herokuapp.com/\\", \\"select window\\");
      return $browser.get(\\"http://the-internet.herokuapp.com/\\").then(val => {
        return val;
      });
    })
    .then( function SetWindow() {
      logger.log(2, \\"Set Window Size Width=1260 Height=1027\\", \\"select window\\");
      return $browser.manage().window().setSize(1260, 1027).then(val => {
        return val;
      });
    })
    .then( function Click() {
      logger.log(3, \\"Click By.linkText(\\\\\\"Multiple Windows\\\\\\")\\", \\"select window\\");
      return $browser.waitForAndFindElement(By.linkText(\\"Multiple Windows\\"), DefaultTimeout).then(el => {
        el.click();
        return Promise.resolve(true);
      });
    })
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then(wHandles=>{
           vars.set(\\"window_handles\\", wHandles);
           return Promise.resolve(true)
        }) 
    })
    .then( function Click() {
          logger.log(4, \\"Click By.linkText(\\\\\\"Click Here\\\\\\")\\", \\"select window\\");
          return $browser.waitForAndFindElement(By.linkText(\\"Click Here\\"), DefaultTimeout).then(el => {
            el.click();
            return Promise.resolve(true);
          });
        })
    .then(_=>{
       return $browser.getAllWindowHandles()
       .then( wHandles=>{
           let prevHandles = new Set(vars.get(\\"window_handles\\"))
           let currHandles = wHandles
           let diff = new Set ([...currHandles].filter(x => !prevHandles.has(x)))  
           vars.set(\\"win9625\\", diff.values().next().value);
           return Promise.resolve(true)
        })
    })
    .then(_=>{
    return  $browser.getWindowHandle()
      .then(handle=>{
        vars.set(\\"root\\", handle)
      })
  })
    .then( function SwitchToWindow() {
      logger.log(5, \\"Switch to Window using Handle vars.get(\\\\\\"win9625\\\\\\")\\", \\"select window\\");
      return Promise.resolve($browser.switchTo().window(vars.get(\\"win9625\\")));
    })
    .then( function VerifyTitle() {
      logger.log(6, \\"Verify Title New Window\\", \\"select window\\");
      return $browser.getTitle().then(result => {
        assert.strictEqual(\\"New Window\\", result.trim());
        return Promise.resolve(true);
      });
    })
    .then( function SwitchToWindow() {
      logger.log(7, \\"Switch to Window using Handle vars.get(\\\\\\"root\\\\\\")\\", \\"select window\\");
      return Promise.resolve($browser.switchTo().window(vars.get(\\"root\\")));
    })
    .then( function VerifyTitle() {
      logger.log(8, \\"Verify Title The Internet\\", \\"select window\\");
      return $browser.getTitle().then(result => {
        assert.strictEqual(\\"The Internet\\", result.trim());
        return Promise.resolve(true);
      });
    })
  	.then(function() {
  		logger.endTestCase(\\"select window\\");
  	}, function(err) {
  		logger.error (err, \\"select window\\");
  		throw(err);
  	});
  
  })
  
"
`;
